"""
    @print_buffer_usage(buf, ex)

Print buffer `buf` usage in expression `ex`.
"""
macro print_buffer_usage(buf, ex)
  _print_buffer_usage(ex, buf)
  quote
    $(esc(ex))
  end
end

is_expr(ex, head::Symbol) = Meta.isexpr(ex,head)

function _print_buffer_usage(ex, buf::Symbol)
  println("# Function to calculate length for buffer $buf")
  println("# autogenerated by @print_buffer_usage")
  println("=============================================")
  display(_peak_buffer_usage(ex, buf))
  println("=============================================")
end

function _peak_buffer_usage(ex, buf::Symbol)
  _ex = ex
  Base.remove_linenums!(_ex)
  exb = _buffer_usage(_ex, buf)
  bargs = []
  push!(bargs, Expr(:(=), Symbol("len$buf"), :(Ref(0))))
  push!(bargs, Expr(:(=), Symbol("peak$buf"), :(Ref(0))))
  if Base.is_expr(exb, :block)
    append!(bargs, exb.args)
  else
    push!(bargs, exb)
  end
  push!(bargs, Expr(:return, Expr(:ref, Symbol("peak$buf"))))
  return Expr(:block, bargs...)
end

"""
    _buffer_usage(ex, buf::Symbol)

Allocations and deallocations together with corresponding `if`s 
in expression `ex`.
"""
function _buffer_usage(ex, buf::Symbol)
  if !(ex isa Expr)
    return
  end
  # go through all expressions in the block and return expressions 
  # that contain alloc!/drop!/reset functions
  if is_expr(ex, :block)
    buf_args = []
    for i in 1:length(ex.args)
      arg = _buffer_usage(ex.args[i], buf)
      if !isnothing(arg)
        push!(buf_args, arg)
      end
    end
    if length(buf_args) > 0
      return Expr(:block, buf_args...)
    end
  elseif is_expr(ex, :(=))
    arg = _buffer_usage(ex.args[2], buf)
    if !isnothing(arg)
      return Expr(:(=), ex.args[1], Expr(:call, :pseudo_alloc!, Symbol("len$buf"), Symbol("peak$buf"), arg))
    end
  elseif is_expr(ex, :call)
    if ex.args[1] == :alloc! && ex.args[2] == buf
      return _bu_replace_alloc(ex)
    elseif ex.args[1] == :drop! && ex.args[2] == buf
      return Expr(:call, :pseudo_drop!, Symbol("len$buf"), ex.args[3:end]...)
    elseif ex.args[1] == :reset! && ex.args[2] == buf
      return Expr(:call, :pseudo_reset!, Symbol("len$buf"))
    end
  elseif is_expr(ex, :if) || is_expr(ex, :elseif) 
    arg = _buffer_usage(ex.args[2], buf)
    if length(ex.args) == 3
      arg2 = _buffer_usage(ex.args[3], buf)
      if !isnothing(arg2)
        return Expr(ex.head, ex.args[1], arg, arg2)
      end
    end
    if !isnothing(arg) 
      return Expr(ex.head, ex.args[1], arg)
    end
  else
    # generic case
    buf_args = []
    for i in 1:length(ex.args)
      arg = _buffer_usage(ex.args[i], buf)
      if !isnothing(arg)
        push!(buf_args, arg)
      end
    end
    if length(buf_args) == 1
      return buf_args[1]
    elseif length(buf_args) > 1
      return Expr(:block, buf_args...)
    end
  end
  return
end

function _bu_replace_alloc(ex)
  @assert ex.head == :call && ex.args[1] == :alloc!
  if length(ex.args) == 3
    len = ex.args[3]
  else
    len = Expr(:call, :*, ex.args[3:end]...)
  end
  return len
end  

"""
    pseudo_alloc!(lenbuf, peakbuf, len)

  Pseudo allocation function to calculate length for buffer.

  The function is used in combination with `@print_buffer_usage`.
"""
function pseudo_alloc!(lenbuf, peakbuf, len)
  lenbuf[] += len
  peakbuf[] = max(peakbuf[], lenbuf[])
  return len
end

"""
    pseudo_drop!(lenbuf, lens...)

  Pseudo drop function to calculate length for buffer.

  The function is used in combination with `@print_buffer_usage`.
"""
function pseudo_drop!(lenbuf, lens...)
  if length(lens) == 1
    lenbuf[] -= lens[1]
  else
    lenbuf[] -= sum(lens)
  end
  return
end

"""
    pseudo_reset!(lenbuf)

  Pseudo reset function to calculate length for buffer.

  The function is used in combination with `@print_buffer_usage`.
"""
function pseudo_reset!(lenbuf)
  lenbuf[] = 0
  return
end
